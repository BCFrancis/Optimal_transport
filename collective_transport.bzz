#
# Executed once at init time
#
include "include/vec2.bzz"

state = -1

function force_vector(rid, data) {
  return math.vec2.newp(-1*(100/data.distance)^2, data.azimuth)
}

function force_sum(rid, data, accum) {
  return math.vec2.add(data, accum)
}
 

function init() {
  reset()

	math.rng.setseed(id)
}

#
# Executed for each step
#
function step() {
	time = time + 1
	if (time > 2 and first){
		state = 0
		first = 0
	}
	if(state == 0){
		y_diff = obj_position[1] - pose.position.y
		x_diff = obj_position[0] - pose.position.x
  	target_angle = math.atan(y_diff, x_diff)
	  angle_diff = target_angle - pose.orientation.yaw
		pi = math.pi
		while (angle_diff > pi) {
      angle_diff = angle_diff + (-2 * pi)
   	}
   	while (angle_diff < -pi) {
      angle_diff = angle_diff + (2 * pi)
   	}
		if (angle_diff >= 0){
			set_wheels(-20.0,20.0)	
		}
		if (angle_diff < 0){
			set_wheels(20.0,-20.0)	
		}
		if (math.abs(angle_diff) < 0.1) {
			state = 1
		}
	}
	if (state == 1) {
		set_wheels(20.0,20.0)	
  	touching = 0
		foreach(proximity, function(key, value) {
      if (value.value > 0.9){		
				touching = 1
			}
    })
		if (touching){
				#gripper_lock()
				set_wheels(0.0,0.0)	
				state = 2
			}
	}
	if (state == 2){
		force = neighbors.map(force_vector).reduce(force_sum, math.vec2.new(0.0, 0.0))
		if(neighbors.count() > 0){
    	math.vec2.scale(force, 1.0 / neighbors.count())
		}
		goto(force.x, force.y)
		debug.print(force.x,  " ", force.y)
	}
}

#
# Executed once upon resetting
#
function reset() {
	state = -1
	turret_enable()
	time = 0
	first = 1
}

#
# Executed once upon closing ARGoS
#
function destroy() {
  # Nothing to do
}

